Nessa aula, será criado um mecanismo de geração de mensagens próprio da engine e também será criado um wrapper para as surfaces da SDL.

Faça o download do arquivo correspondente no link abaixo:

<a href='/schifers/files/Aula2.zip'>Aula 2</a>


Três novas classes serão acrescentadas ao modelo:

- Input
- Message
- Surface

A classe Input será a responsável por controlar a fila de mensagens da engine. Ela receberá as mensagens da SDL e irá enfileirá-las para processamento posterior.

A classe Message é a classe responsável por armazenar o conteúdo dessas mensagens. Ela possui o mesmo formato das mensagens que o Windows gera. Ela foi criada dessa forma para que a portabilidade da engine para DirectX seja facilitada.

A classe Surface é um wrapper para a estrutura SDL_Surface da SDL. Esse wrapper foi criado para que no futuro, caso o jogo necessite ser portado para DirectX, não seja necessário mudar nada na programação do jogo em si. Somente será necessário mudar essa classe para a nova forma de carregar imagens do DirectX.

O diagrama de classes fica assim:

<center>
<img src='/schifers/images/class02/fig01.jpg' border='0'>
</center>

A primeira das novas classes que será mostrada é a classe Message. Observe como funciona o mecanismo de tratamento de mensagens na API do Windows para que entenda o porquê dessa classe ter sido construída com esses parâmetros.

<code>
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;
        case WM_DESTROY:
            PostQuitMessage(0);
        break;
        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}
</code>

A função acima é uma função de tratamento de mensagens utilizada por um programa Win32. Como vocês podem observar, a função que processa os eventos de uma janela no Windows recebe como parâmetro o handle para a janela (hwnd), recebe o tipo da mensagem (msg) e recebe ainda dois parâmetros: wParam e lParam.

HWND hwnd => trata-se de um endereço para a janela que recebe os eventos.
UINT msg => trata-se de uma variável do tipo unsigned int, ou seja, UINT, tipo declarado na API do Windows.
WPARAM wParam => trata-se de um parâmetro do tipo WPARAM, ou seja, WPARAM é um tipo declarado também na API do Windows que representa um WORD, ou seja, um unsigned int.
LPARAM lParam => trata-se de um parâmetro do tipo LPARAM, ou seja, LPARAM é também declarado na API e representa um unsigned long.

Os tipos que serão precisos na engine criada aqui são somente os dois últimos: WPARAM e LPARAM. Eles serão declarados no arquivo Global.h da seguinte forma:

<code>
typedef unsigned int    WPARAM;
typedef unsigned long   LPARAM;
</code>

Além desses dois atributos, a classe Message ainda terá o tipo da mensagem, no caso da engine será um int e também um ponteiro void* para os dados que possam ser encaminhados nessa mensagem.

Quanto às operações dessa classe, basicamente, são métodos de acesso aos atributos encapsulados dentro dela. Esses métodos recebem o nome de getters e setters pois eles servem somente para buscar o valor do atributo e preencher o atributo com um valor passado.

A próxima classe a ser apresentada é a classe Input. Essa classe faz uso da STL, ou seja, Standard Template Library do C++. Para ter uma idéia melhor do que se trata a STL dê uma lida no link abaixo:

<a href='http://en.wikipedia.org/wiki/Standard_Template_Library'>Wikipedia - Standard Template Library - STL</a>


O único atributo dessa classe é um fila de dupla entrada (deque, double ended queue) que é responsável por armazenar a fila de mensagens recebidas através dos eventos que ocorrem na SDL. Esse tipo de estrutura está implementada na STL. Para uma visão mais aprofundada dessa estrutura de dados dê uma lida no link abaixo:

<a href='http://en.wikipedia.org/wiki/Deque'>Double Ended Queue (deque)</a>


Basicamente, a fila de dupla entrada enfileira as mensagens que vão chegando uma após a outra. O processamento das mensagens é feita na ordem da chegada delas, ou seja, as primeiras que chegam são as primeiras que são processadas. Esse método possui uma abreviação na teoria: FIFO, "first in first out". Existe uma outra estrutura de dados que usa o método LIFO, "last in first out" e é a estrutura com o nome de pilha. Na pilha, temos os objetos empilhados e os primeiros a serem processados são aqueles que se encontram no topo da pilha.

Voltando a fila de mensagens. Basicamente, ela deve possuir duas operações: a de colocar mensagens na fila e a de tirar a primeira mensagem da fila. Como essas operações já estão implementadas pela STL, não precisamos nos preocupar com a lógica dela e sim somente criar operações de acesso a elas na nossa classe Input.

A classe Input possui as duas operações: GetDeque() que retorna a referência a fila de mensagens, permitindo que o programa use as operações já implementadas pela STL e o método PopMessage() que retorna uma referência para um objeto do tipo Message.

Com essas operações, a engine é capaz de utilizar a fila de mensagens e fazer o processamento de cada uma delas.

Por último, a classe Surface será apresentada. Essa classe, como foi dito, é uma classe utilizada para armazenar as imagens da engine. Uma imagem possui os seguintes atributos:

iWidth => largura em pixels da imagem
iHeight => altura em pixels da imagem
iX => posição X aonde a imagem será desenhada
iY => posição Y aonde a imagem será desenhada

Além desses atributos, ainda existe uma referência necessária para a estrutura SDL_Surface da SDL que representa imagem.

Todos esses atributos possuem seus getters and setters:

<code>
    int GetWidth();
    void SetWidth(int w);
    int GetHeight();
    void SetHeight(int h);
    int GetX();
    void SetX(int x);
    int GetY();
    void SetY(int y);
</code>

Além dos getters and setters desses atributos, os outros métodos da classe são:

- GetSurface(): que retorna uma referência para a SDL_Surface da imagem
- LoadFromFile(): que carrega a SDL_Surface a partir de um arquivo em disco, ela recebe o nome do arquivo como parâmetro
- Blit(): responsável por desenhar a imagem na tela, recebe a tela como parâmetro
- SetTransparent(): transforma a cor rosa pura (255, 0, 255) em transparente
- FreeSurface(): libera a memória alocada para a SDL_Surface

Pronto, com essa estrutura de classes é possível modificar o recebimento de mensagens e incluir uma imagem na janela principal do programa.

O loop principal do jogo no arquivo SdlApplication.cpp, no método Run(), teve que ser alterado:

<code>
    this->pInput = new Input();

	// Game initialization
	this->Start();

	// Main Loop
	while(true)
	{
        this->GenerateInput();

        SDL_FillRect(this->pScreen, NULL, SDL_MapRGB( this->pScreen->format, 0, 0, 0));

		if(!this->Loop())
		{
		    break;
		}

        SDL_UpdateRect(this->pScreen, 0, 0, 0, 0);
	}

	// Game finalization
	this->End();

    delete this->pInput;
</code>

Como vocês podem observar, no início do loop, foi necessário instanciar a classe Input e assim que o loop for encerrado, a memória alocada estará sendo liberada com o comando delete.

Dentro do loop, o primeiro método chamado agora é o GenerateInput(). Esse método será responsável por enfileirar as mensagens criadas pelos eventos que a SDL recebe. A implementação dele está logo abaixo:

<code>
void SdlApplication::GenerateInput()
{
    while(SDL_PollEvent(this->pEvent))
    {
        if(this->pEvent->type == SDL_QUIT)
        {
            this->pMessage = new Message();

            this->pMessage->SetType(MSG_EXIT);

            this->pInput->GetDeque()->push_back(this->pMessage);
        }
        if(this->pEvent->type == SDL_KEYDOWN)
        {
            if(this->pEvent->key.keysym.sym == SDLK_ESCAPE)
            {
                SDL_Event quit;
                quit.type = SDL_QUIT;
                SDL_PushEvent(&quit);
            }
        }
    }
}
</code>

Com esse método, não será necessário utilizar tipos específicos da SDL no código do jogo em si. Essa parte de geração de mensagens fica isolada do arquivo Main.cpp, portanto, se o jogo tiver que ser portado para DirectX, só será necessário alterar o código da SdlApplication, incluindo a parte de geração de mensagens (método GenerateInput).

Em seguida existe uma chamada para a função SDL_FillRect(). Ela preenche toda a tela (SDL_Surface) com a cor que for passada como parâmetro. Nesse caso aqui vocês podem observar que foi passada a cor preta: RGB (0, 0, 0).

<code>
SDL_FillRect(this->pScreen, NULL, SDL_MapRGB( this->pScreen->format, 0, 0, 0));
</code>

A função acima preenche toda a tela com a cor preta, pois quando o segundo parâmetro é passado como nulo, a SDL preenche toda a superfície passada no primeiro parâmetro com a cor passada no terceiro parâmetro. Caso não se queira preencher a superfície inteira, deve-se passar uma estrutura SDL_Rect preenchida no segundo parâmetro.

Ainda existe uma chamada à função SDL_MapRGB na chamada da SDL_FillRect.

<a href='http://www.libsdl.org/cgi/docwiki.cgi/SDL_MapRGB'>SDL_MapRGB</a>


Essa função mapeia uma cor para o formato da superfície utilizada.

Temos finalmente, logo após a chamada ao método Loop(), uma chamada à função SDL_Flip.

<a href='http://www.libsdl.org/cgi/docwiki.cgi/SDL_Flip'>SDL_Flip</a>


Essa função faz a troca dos buffers entre o que está em memória e o que está na tela, fazendo com que a tela seja atualizada. Para que essa função faça o flipping na placa de vídeo é necessário que na chamada da SDL_SetVideoMode seja passado os parâmetros SDL_HWSURFACE e SDL_DOUBLEBUF.

Explicadas as alterações que foram feitas no método Run() da SdlApplication, deve-se entender as mudanças na implementação dos métodos Start(), Loop() e End() para que a imagem aparecesse na tela.

A primeira mudança, foi instanciar na classe Game uma superfície para a imagem. Portanto, ao observar o arquivo Main.h você pode notar as seguintes linhas:

<code>
    private:
        Surface* pImage;
</code>

Portanto, você pode observar que foi acrescentado um atributo privado do tipo Surface que é um endereço de uma área em memória, pois trata-se de um ponteiro.

Observe o novo método Start():

<code>
void Game::Start()
{
    this->pImage = new Surface();

    this->pImage->LoadFromFile("natal.bmp");
}
</code>

Nesse método, nota-se a inicialização da superfície da imagem e o carregamento do arquivo físico para a estrutura SDL_Surface dentro do objeto que o ponteiro pImage aponta.

Em seguida, observe o método End():

<code>
void Game::End()
{
    this->pImage->FreeSurface();

    delete this->pImage;
}
</code>

Após a utilização da imagem, o método End() libera a superfície da SDL que está dentro do objeto pImage do tipo Surface e o método ainda libera o próprio objeto pImage chamando o comando delete.

Por último, veja o método Loop():

<code>
bool Game::Loop()
{
    Message* msg = this->pInput->PopMessage();
    while(msg)
    {
        if(msg->GetType() == MSG_EXIT)
        {
            return false;
        }

        msg = this->pInput->PopMessage();
    }

    this->pImage->Blit(this->pScreen);

    return true;
}
</code>

O método Loop() começa tratando todas as mensagens que ele encontra dentro da fila de mensagens da engine que está sendo criada. A única mensagem que está programada no momento, é a MSG_EXIT, ou seja, a que faz o loop terminar caso ocorra uma mensagem de saída.

Em seguida, o método chama a operação de desenho em tela do objeto pImage passando a tela pScreen que também é uma superfície da nossa engine.

Caso o método retorne true, ele continua executando o jogo sem sair do loop. Caso contrário, o jogo recebe false e o loop termina chegando no comando break.

Com isso terminamos mais uma aula. Na próxima iremos trabalhar um pouco mais dos fundamentos para começar a programar um jogo.

